"""
Generate robocopy commands to mirror the cataloged files to local storage.
Robocopy is much faster and more reliable than Python's shutil for large transfers.
"""
import argparse
from pathlib import Path
from catalog.db import connect

def format_bytes(size):
    """Format bytes into human readable string."""
    if size < 1024:
        return f"{size} B"
    elif size < 1024**2:
        return f"{size/1024:.2f} KB"
    elif size < 1024**3:
        return f"{size/(1024**2):.2f} MB"
    else:
        return f"{size/(1024**3):.2f} GB"

def main():
    parser = argparse.ArgumentParser(
        description="Generate robocopy commands to mirror cataloged files"
    )
    parser.add_argument(
        "--dest",
        required=True,
        help="Destination root directory (e.g., C:\\Users\\brand\\Projects\\Server)"
    )
    parser.add_argument(
        "--source-prefix",
        default="S:\\",
        help="Source prefix to copy from (default: S:\\)"
    )
    parser.add_argument(
        "--db",
        default="data/projects.db",
        help="Path to database (default: data/projects.db)"
    )
    parser.add_argument(
        "--threads",
        type=int,
        default=8,
        help="Number of robocopy threads (default: 8, max: 128)"
    )
    parser.add_argument(
        "--output",
        default="robocopy_commands.bat",
        help="Output batch file name (default: robocopy_commands.bat)"
    )
    
    args = parser.parse_args()
    
    db_path = Path(args.db)
    dest_root = Path(args.dest)
    source_prefix = args.source_prefix.rstrip('\\') + '\\'
    
    print("=" * 100)
    print("ROBOCOPY COMMAND GENERATOR")
    print("=" * 100)
    print()
    print(f"Database: {db_path}")
    print(f"Source: {source_prefix}")
    print(f"Destination: {dest_root}")
    print(f"Threads per robocopy: {args.threads}")
    print()
    
    # Connect to database
    con = connect(db_path)
    cur = con.cursor()
    
    # Get all unique directories
    print("Analyzing directory structure...")
    cur.execute("""
        SELECT DISTINCT dir, COUNT(*) as file_count, SUM(size_bytes) as dir_size
        FROM files
        WHERE state NOT IN ('error', 'missing')
          AND path_abs LIKE ?
        GROUP BY dir
        ORDER BY dir
    """, (f"{source_prefix}%",))
    
    directories = cur.fetchall()
    total_dirs = len(directories)
    
    # Calculate totals
    cur.execute("""
        SELECT COUNT(*), SUM(size_bytes)
        FROM files
        WHERE state NOT IN ('error', 'missing')
          AND path_abs LIKE ?
    """, (f"{source_prefix}%",))
    
    total_files, total_bytes = cur.fetchone()
    
    print(f"Found {total_dirs:,} directories")
    print(f"Total files: {total_files:,}")
    print(f"Total size: {format_bytes(total_bytes)} ({total_bytes:,} bytes)")
    print()
    
    # Estimate time
    # Robocopy with multi-threading can be very fast, especially on gigabit+
    copy_speed_mbps = 200  # MB/s - conservative for robocopy with threading
    estimated_seconds = total_bytes / (copy_speed_mbps * 1024 * 1024)
    estimated_minutes = estimated_seconds / 60
    estimated_hours = estimated_minutes / 60
    
    print(f"Estimated copy time @ {copy_speed_mbps} MB/s:")
    if estimated_hours >= 1:
        print(f"  ~{estimated_hours:.1f} hours ({estimated_minutes:.0f} minutes)")
    else:
        print(f"  ~{estimated_minutes:.1f} minutes")
    print()
    
    # Generate robocopy batch file
    output_file = Path(args.output)
    
    print(f"Generating batch file: {output_file}")
    print()
    
    with output_file.open('w', encoding='utf-8') as f:
        f.write("@echo off\n")
        f.write("REM Robocopy commands to mirror cataloged files to local storage\n")
        f.write("REM Generated by Corpus Cataloger\n")
        f.write("\n")
        f.write(f"REM Source: {source_prefix}\n")
        f.write(f"REM Destination: {dest_root}\n")
        f.write(f"REM Total files: {total_files:,}\n")
        f.write(f"REM Total size: {format_bytes(total_bytes)}\n")
        f.write("\n")
        f.write("echo Starting file copy...\n")
        f.write("echo.\n")
        f.write(f"set SOURCE={source_prefix}\n")
        f.write(f"set DEST={dest_root}\n")
        f.write("\n")
        
        # Single robocopy command for the entire drive - much more efficient!
        f.write("REM Copy all files from S:\\ to destination\n")
        f.write("REM /MIR = Mirror (copy all, remove extra)\n")
        f.write("REM /MT:n = Multi-threaded (n threads)\n")
        f.write("REM /R:2 = Retry 2 times on failed copies\n")
        f.write("REM /W:5 = Wait 5 seconds between retries\n")
        f.write("REM /NFL /NDL = Don't log file/directory names (faster)\n")
        f.write("REM /NP = No progress percentage (faster)\n")
        f.write("REM /BYTES = Show sizes in bytes\n")
        f.write("REM /TEE = Output to console and log file\n")
        f.write("REM /LOG = Log file\n")
        f.write("\n")
        
        # For FULL mirror (recommended - fastest)
        f.write("REM Option 1: FULL MIRROR - Fastest, copies everything, removes extra files\n")
        f.write(f'robocopy "%SOURCE%" "%DEST%" /MIR /MT:{args.threads} /R:2 /W:5 /BYTES /TEE /LOG:robocopy_full.log\n')
        f.write("\n")
        
        # For COPY only (no deletion)
        f.write("REM Option 2: COPY ONLY - Doesn't delete extra files at destination\n")
        f.write(f'REM robocopy "%SOURCE%" "%DEST%" /E /MT:{args.threads} /R:2 /W:5 /BYTES /TEE /LOG:robocopy_copy.log\n')
        f.write("\n")
        
        # For UPDATE only (skip existing)
        f.write("REM Option 3: UPDATE ONLY - Skip files that exist and are same size/date\n")
        f.write(f'REM robocopy "%SOURCE%" "%DEST%" /E /XO /MT:{args.threads} /R:2 /W:5 /BYTES /TEE /LOG:robocopy_update.log\n')
        f.write("\n")
        
        f.write("echo.\n")
        f.write("echo Copy complete!\n")
        f.write("echo Check robocopy_full.log for details\n")
        f.write("pause\n")
    
    print("=" * 100)
    print("BATCH FILE GENERATED")
    print("=" * 100)
    print()
    print(f"File: {output_file.absolute()}")
    print()
    print("The batch file contains 3 options:")
    print()
    print("1. FULL MIRROR (recommended, currently enabled)")
    print("   - Copies all files from S:\\ to destination")
    print("   - Removes files at destination that aren't in source")
    print("   - Uses /MIR flag")
    print()
    print("2. COPY ONLY (commented out)")
    print("   - Copies all files but doesn't delete anything")
    print("   - Uses /E flag")
    print("   - To use: uncomment and comment out option 1")
    print()
    print("3. UPDATE ONLY (commented out)")
    print("   - Only copies new or changed files")
    print("   - Skips files that already exist with same size/date")
    print("   - Uses /E /XO flags")
    print("   - To use: uncomment and comment out option 1")
    print()
    print("=" * 100)
    print("TO RUN:")
    print("=" * 100)
    print()
    print(f"1. Review the batch file: {output_file}")
    print("2. Run as Administrator (for best performance):")
    print(f"   {output_file.absolute()}")
    print()
    print("ROBOCOPY BENEFITS:")
    print("  - Multi-threaded (8 threads = ~8x faster)")
    print("  - Automatically resumes if interrupted")
    print("  - Preserves timestamps and attributes")
    print("  - Skips unchanged files")
    print("  - Shows real-time progress")
    print("  - Creates detailed log file")
    print()
    print("IMPORTANT NOTES:")
    print("  - /MIR will DELETE files at destination that aren't in source!")
    print("  - To keep extra files, use COPY ONLY option instead")
    print("  - Can be safely interrupted (Ctrl+C) and resumed")
    print("  - Run again to update changed files only")
    print()
    
    con.close()

if __name__ == "__main__":
    main()
