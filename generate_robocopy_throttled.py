"""
Generate a network-friendly robocopy script with throttling.
"""
import argparse
from pathlib import Path
from catalog.db import connect
from collections import defaultdict

def format_bytes(size):
    """Format bytes into human readable string."""
    if size < 1024:
        return f"{size} B"
    elif size < 1024**2:
        return f"{size/1024:.2f} KB"
    elif size < 1024**3:
        return f"{size/(1024**2):.2f} MB"
    else:
        return f"{size/(1024**3):.2f} GB"

def main():
    parser = argparse.ArgumentParser(
        description="Generate network-friendly robocopy commands"
    )
    parser.add_argument(
        "--dest",
        required=True,
        help="Destination root directory"
    )
    parser.add_argument(
        "--source-prefix",
        default="S:\\",
        help="Source prefix (default: S:\\)"
    )
    parser.add_argument(
        "--db",
        default="data/projects.db",
        help="Path to database (default: data/projects.db)"
    )
    parser.add_argument(
        "--throttle-mbps",
        type=int,
        default=10,
        help="Throttle bandwidth in MB/s (default: 10)"
    )
    parser.add_argument(
        "--inter-packet-gap",
        type=int,
        default=20,
        help="Inter-packet gap in milliseconds (default: 20)"
    )
    parser.add_argument(
        "--output",
        default="robocopy_throttled.bat",
        help="Output batch file name"
    )
    
    args = parser.parse_args()
    
    db_path = Path(args.db)
    dest_root = Path(args.dest)
    source_prefix = args.source_prefix.rstrip('\\') + '\\'
    
    print("=" * 100)
    print("NETWORK-FRIENDLY ROBOCOPY GENERATOR")
    print("=" * 100)
    print()
    print(f"Database: {db_path}")
    print(f"Source: {source_prefix}")
    print(f"Destination: {dest_root}")
    print(f"Bandwidth limit: {args.throttle_mbps} MB/s")
    print(f"Inter-packet gap: {args.inter_packet_gap} ms")
    print()
    
    # Connect to database
    con = connect(db_path)
    cur = con.cursor()
    
    # Get all files and group by directory
    print("Analyzing cataloged files...")
    cur.execute("""
        SELECT dir, name, size_bytes
        FROM files
        WHERE state NOT IN ('error', 'missing')
          AND path_abs LIKE ?
        ORDER BY dir, name
    """, (f"{source_prefix}%",))
    
    # Group files by directory
    dir_files = defaultdict(list)
    total_files = 0
    total_bytes = 0
    
    for dir_path, filename, size in cur.fetchall():
        dir_files[dir_path].append(filename)
        total_files += 1
        total_bytes += size
    
    total_dirs = len(dir_files)
    
    print(f"Found {total_dirs:,} directories")
    print(f"Total files: {total_files:,}")
    print(f"Total size: {format_bytes(total_bytes)}")
    print()
    
    # Calculate estimated time with throttling
    estimated_seconds = total_bytes / (args.throttle_mbps * 1024 * 1024)
    estimated_hours = estimated_seconds / 3600
    
    print(f"Estimated time @ {args.throttle_mbps} MB/s: {estimated_hours:.1f} hours")
    print()
    
    def cmd_quote(path: str) -> str:
        sanitized = path.replace('"', r'\"')
        if sanitized.endswith('\\'):
            sanitized += '\\'
        return f'"{sanitized}"'

    # Generate robocopy batch file
    output_file = Path(args.output)
    
    print(f"Generating batch file: {output_file}")
    print()
    
    command_count = 0

    with output_file.open('w', encoding='utf-8') as f:
        f.write("@echo off\n")
        f.write("REM Network-friendly robocopy with bandwidth throttling\n")
        f.write("REM Generated by Corpus Cataloger\n")
        f.write("\n")
        f.write(f"REM Source: {source_prefix}\n")
        f.write(f"REM Destination: {dest_root}\n")
        f.write(f"REM Total files: {total_files:,}\n")
        f.write(f"REM Total size: {format_bytes(total_bytes)}\n")
        f.write(f"REM Bandwidth limit: {args.throttle_mbps} MB/s\n")
        f.write(f"REM Inter-packet gap: {args.inter_packet_gap} ms\n")
        f.write("\n")
        f.write("echo Network-friendly file copy with throttling...\n")
        f.write("echo.\n")
        f.write(f'echo Bandwidth limit: {args.throttle_mbps} MB/s\n')
        f.write(f'echo Total: {total_files:,} files ({format_bytes(total_bytes)})\n')
        f.write(f'echo Estimated time: {estimated_hours:.1f} hours\n')
        f.write("echo.\n")
        f.write("echo Press Ctrl+C to pause/stop at any time\n")
        f.write("echo.\n")
        f.write("\n")
        
        # Single robocopy command with throttling options
        # /IPG:n = Inter-Packet Gap (ms) - adds delay between packets
        # /MT:1 = Single thread (less aggressive)
        # /R:2 = Retry 2 times
        # /W:5 = Wait 5 seconds between retries
        
        # Convert throttle from MB/s to bits/s for robocopy /IPG calculation
        # IPG is the gap between packets, not a bandwidth limit directly
        # We'll use MT:1 and IPG together
        
        f.write("REM Using single-threaded copy with inter-packet gap for network friendliness\n")
        f.write("REM /MT:1 = Single thread (less aggressive)\n")
        f.write(f"REM /IPG:{args.inter_packet_gap} = {args.inter_packet_gap}ms delay between packets\n")
        f.write("REM /R:2 = Retry 2 times on error\n")
        f.write("REM /W:5 = Wait 5 seconds between retries\n")
        f.write("\n")
        
        f.write("REM Copying cataloged files only (one robocopy call per file)\n")
        f.write("REM This avoids transferring items not present in the database.\n")
        f.write("\n")

        for idx, (dir_path, filenames) in enumerate(dir_files.items(), 1):
            rel_dir = dir_path[len(source_prefix):] if dir_path.startswith(source_prefix) else dir_path
            dest_dir = dest_root / rel_dir if rel_dir else dest_root

            display_dir = rel_dir if rel_dir else '(root)'
            f.write(f"echo {idx}/{total_dirs}: {display_dir}\n")

            src_cmd = cmd_quote(dir_path)
            dest_cmd = cmd_quote(str(dest_dir))

            for filename in filenames:
                command_count += 1
                file_cmd = cmd_quote(filename)
                f.write(
                    f"robocopy {src_cmd} {dest_cmd} {file_cmd} /IPG:{args.inter_packet_gap} /R:2 /W:5 /NFL /NDL /NP /BYTES /TEE /LOG+:robocopy_throttled.log\n"
                )

            f.write("echo.\n")
        
        f.write("echo.\n")
        f.write("echo Copy complete!\n")
        f.write("echo Check robocopy_throttled.log for details\n")
        f.write("pause\n")
    
    print("=" * 100)
    print("THROTTLED BATCH FILE GENERATED")
    print("=" * 100)
    print()
    print(f"File: {output_file.absolute()}")
    print()
    print(f"Robocopy commands generated: {command_count:,}")
    print()
    print("NETWORK-FRIENDLY FEATURES:")
    print(f"  • Single-threaded copying (less aggressive)")
    print(f"  • {args.inter_packet_gap}ms delay between packets")
    print(f"  • Target bandwidth: ~{args.throttle_mbps} MB/s")
    print("  • Transfers only files recorded in the database")
    print()
    print("ADVANTAGES:")
    print("  • Won't overwhelm network bandwidth")
    print("  • Other users can work normally")
    print("  • Can run during business hours")
    print("  • Automatically resumes if interrupted")
    print()
    print("DISADVANTAGES:")
    print(f"  • Slower: ~{estimated_hours:.1f} hours (vs ~0.3 hours at full speed)")
    print()
    print("TO RUN:")
    print(f"  {output_file.absolute()}")
    print()
    print("TO ADJUST SPEED:")
    print("  --throttle-mbps 5   (very gentle, ~40 hours)")
    print("  --throttle-mbps 10  (gentle, ~20 hours) [current]")
    print("  --throttle-mbps 20  (moderate, ~10 hours)")
    print("  --throttle-mbps 50  (fast, ~4 hours)")
    print()
    
    con.close()

if __name__ == "__main__":
    main()
